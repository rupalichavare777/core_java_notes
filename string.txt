â­ STRINGS + STRING POOL + IMMUTABILITY + MEMORY BEHAVIOR (SUPER DEEP)

This topic is asked in EVERY interview because Strings touch:

Memory

Immutability

ClassLoader

Heap

Method Area

Pass-by-value

Wrapper behavior

Multithreading

Performance

Letâ€™s go step-by-step, from the deepest fundamentals to the trickiest interview traps.

ğŸš€ CHAPTER 1 â€” What exactly is a String in Java?

Many developers think â€œString is a data typeâ€ â€” WRONG.

âœ” String is a final class
âœ” Represents immutable sequence of characters
âœ” Lives in Heap
âœ” Literals live in String Pool (inside Method Area)

Key takeaway:
String objects can live BOTH in heap and in pool, depending on how you create them.

ğŸš€ CHAPTER 2 â€” STRING POOL (DEEP INTERNALS)
Where is the String Pool?

ğŸ“Œ In Method Area / Metaspace, not heap.

What does the pool contain?

All literal Strings from your code

Interned Strings

Class constant pool references

Why pool exists?

Reuse common strings

Save memory

Speed (reference comparison)

â­ CHAPTER 3 â€” Literal String vs new String()
Case 1: Literal
String s1 = "java";
String s2 = "java";


Memory:

String Pool:
    "java"   â† s1, s2


âœ” SAME object
âœ” SAME memory address
âœ” s1 == s2 â†’ true
âœ” No heap object created

Case 2: new String()
String s1 = new String("java");


Memory:

String Pool:
    "java"

Heap:
    "java" â† new object


âœ” Two objects created
âœ” One in pool (literal)
âœ” One in heap (via new)
âœ” s1 == "java" â†’ false

â­ CHAPTER 4 â€” Why String is immutable?

This is one of Javaâ€™s top interview questions. REAL reasons:

âœ” 1. String Pool Requires Immutability

If Strings were mutable, someone could modify "java" in pool â†’ breaks entire application.

âœ” 2. Security

Used heavily in:

File paths

ClassLoader

URLs

DB credentials

Socket names

If mutable â†’ HUGE security issues.

âœ” 3. HashMap keys

Strings are commonly used as keys.

If value changed â†’ hashCode changes â†’ bucket broken â†’ data lost.

âœ” 4. Thread safety

Immutable objects are inherently thread-safe.

â­ CHAPTER 5 â€” What is intern()?
String s1 = new String("java");
String s2 = s1.intern();
String s3 = "java";


Memory:

Pool:
   "java"   â† s2, s3

Heap:
   "java"   â† s1


âœ” s2 == s3 â†’ true
âœ” s1 == s2 â†’ false

intern() returns pool version.

ğŸš€ CHAPTER 6 â€” How many objects created?
Case:
String s = new String("hello");


Answer:

Literal "hello" â†’ pool

new String("hello") â†’ heap

Total = 2 objects

ğŸš€ CHAPTER 7 â€” CONCATENATION RULES (IMPORTANT)
Case 1 â€” Compile-Time
String s = "ab" + "cd";


âœ” Compiler optimizes â†’ "abcd"
âœ” Stored in pool
âœ” 1 object only

Case 2 â€” Runtime
String a = "ab";
String b = "cd";
String c = a + b;


âœ” New object created in heap
âœ” Because compiler cannot know values beforehand

Memory:

Pool:
   "ab"
   "cd"
   (maybe "abcd" not added automatically)

Heap:
   "abcd" â† c

Case 3 â€” Using StringBuilder
String c = a + b + d + e;


Compiler converts to:

new StringBuilder().append(a).append(b).append(d).append(e).toString();


âœ” Efficient
âœ” Only one final object created

â­ CHAPTER 8 â€” StringBuilder vs StringBuffer vs String
Feature	String	StringBuilder	StringBuffer
Mutable	âŒ No	âœ” Yes	âœ” Yes
Thread-safe	âœ” Yes	âŒ No	âœ” Yes
Fast?	Slow	Fastest	Slower
Uses	Constants	Loops, concatenation	Multi-thread
â­ CHAPTER 9 â€” PASS-BY-VALUE with Strings
String s = "hello";

public void change(String s) {
    s = "world";
}

change(s);
System.out.println(s); 


Output:

hello


Why?

String is immutable

Java is pass-by-value

Assignment inside method does NOT affect original

Memory:

Outside: s â†’ "hello"
Inside change: s â†’ "world" (different reference)

â­ CHAPTER 10 â€” TRICKY INTERVIEW QUESTIONS
Q1: What is the output?
String s1 = "abc";
String s2 = "abc";
System.out.println(s1 == s2);


true
Same pool reference.

Q2:
String s1 = new String("abc");
String s2 = new String("abc");
System.out.println(s1 == s2);


false
Two heap objects.

Q3:
String s1 = new String("abc");
String s2 = s1.intern();
String s3 = "abc";

System.out.println(s2 == s3);
System.out.println(s1 == s2);


Output:

true
false

Q4: Which is faster:

String or StringBuilder?

StringBuilder â†’ fast
Because String is immutable â†’ creates new objects every time.

Q5: Why is String final?

To preserve immutability.
If subclass modifies internal char array â†’ pool breaks.

â­ CHAPTER 11 â€” MEMORY DIAGRAMS (Interview Style)
Example:
String s1 = "hello";
String s2 = s1;
String s3 = new String("hello");


Memory:

Pool:
   "hello"  â† s1, s2

Heap:
   "hello"  â† s3

â­ CHAPTER 12 â€” SUMMARY (1-MINUTE REVISION)

âœ” String is immutable
âœ” String literals stored in String Pool
âœ” "abc" reused, new String("abc") creates new heap object
âœ” intern() returns pool reference
âœ” Compile-time concat stored in pool
âœ” Runtime concat â†’ heap
âœ” == compares reference, .equals() compares value
âœ” StringBuilder for performance
âœ” StringBuffer for thread safety